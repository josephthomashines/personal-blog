09/06/2020
<meta
  name="description"
  content="making a url shortener using go and boltdb, deployed using docker"
  >
-----
<div class="container">
    <p>
        For a while now, I had wanted to develop and deploy a simple web
        application in
        <a
          href="https://golang.org/"
          target="_blank"
          rel="noopener noreferrer">
            go</a>.
        This language was brought to my attention by one of my professors
        who is big into both systems programming and operating systems
        themselves; the type of person that is still running Plan9 on
        his personal machine today. He is a great professor, and I would
        eventually take a class of his on the Inferno operating system,
        which was also created by the core members of the Plan9 team. A lot
        of the decisions made in this OS, from practices in the kernel source
        to the user space virtual machine are clearly the roots of go.
        After spending some time tinkering with this language, I set out
        to using it in my first crack at the
        <a
          href="https://adventofcode.com/"
          target="_blank"
          rel="noopener noreferrer">
            Advent of Code</a>, in 2019. I made it further than I expected,
        and learned a lot about the language in the process. Unfortunately,
        <a
          href="https://github.com/ephjos/aoc"
          target="_blank"
          rel="noopener noreferrer">
            I stoppped at Day 22</a>,
        being shot down by a problem that involved some
        complex modulo arithmetic (shortly after, I would take my first
        cryptography course, tempting me to dive back in and complete the
        challenge). After some time away from the language, I finally decided
        on a simple project that I could create and deploy.
    </p>
    <p>
        Url shorteners are fairly straightforward. The core functionality
        is binding a shortened path to a target url, and then performing
        that redirect. This maps nicely to having one endpoint that performs
        either option based on if the request is a GET or POST.
    </p>
<pre class="text-white">
motivation
conceptual walkthrough
implementation details
deployment
    setting up subdomain
security concerns
    xss
    invalid urls (server-side injection)
clsoing thoughts
</pre>
</div>
