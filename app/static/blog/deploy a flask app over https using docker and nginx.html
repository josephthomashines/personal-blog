<div class="blog-container">
  <head>
    <meta
      name="description"
      content="Deploy a Flask app over https using docker and nginx">
  </head>
  <p>
    Flask is a incredibly powerful micro-framework for making
    simple webservers using python. In this post, I will go over
    a simple way to take a Flask application and deploy it
    on a server, using docker, and with https enabled. This
    setup will also make adding additional websites under the
    same address dead simple. This guide will assume that you have
    python and docker installed.
  </p>

  <p>
    First, we need a Flask app to deploy. Any application
    will do, but you can use my example
    <a
      href="https://github.com/ephjos/flask-docker-example"
      target="_blank"
      rel="noopener noreferrer"
      >
      project here.
    </a>
      While this project is already setup for you, I'll go
      over how to set your own up, if you do not want to use
      the example. If you wish to use the example, and don't
      care about how to set it up, skip ahead to
      <a href="#deploy">Deploying Our App</a>.
  </p>

  <h2 id="setup">Project Setup</h2>
  <p>
    The root of our project will look like:
    <pre>
      <code class="plaintext">
|
+- app/
+- dockerfile
      </code>
    </pre>
  </p>
  <p>
    I will go over the details of the dockerfile in
    the <a href="#dockerize">Dockerize</a> section.
    In my example, I also include some scripts and
    a Makefile to make using the docker image easier,
    but this is not necessary.
    Our project itself can be found in the app/
    directory. This directory has the structure:
    <pre>
      <code class="plaintext">
|
+- static/
+- templates/
+- main.py
+- requirements.txt
      </code>
    </pre>
  </p>
  <p>
    The static/ directory contains all of the static files we
    wish to serve. In my example, this is where both the bootstrap
    library and my own css files live. I also like to keep any images
    or files I plan on using here. The templates/ directory contains
    our jinja templates for pages we want to be able to populate
    dynamically. To get started, I recommend a simple base.html
    file, which is included by every other template, and an index.html
    file, which is the index page for our site. main.py
    contains the source for the server, and requirements.txt keeps track
    of our dependencies. I like to use virtualenv to manage my
    python environments, but requirements.txt is a good idea to keep
    regardless.
  </p>
  <p>
    The core of the server can be found in the main.py file, which
    looks as follows:
    <pre>
      <code class="python">
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/<name>')
def generic(name):
    return render_template(name + '.html')

if __name__ == "__main__":
    app.run(port=8080, debug=True)
      </code>
    </pre>
  </p>
  <p>
    This instantiates a Flask server (app), and
    defines how to serve files to different routes.
    I have included a generic route definition, as well
    as one for the index page. Of course, for your website
    to do anything interesting on the backend, then this
    file will have to be made more complex. Finally, I also
    included the app.run() line which will allow us to run
    the development server directly without using our docker
    container.
  </p>
  <p>
    This leaves us with the final project structure of:
    <pre>
      <code class="plaintext">
|
+- app/
|  |
|  +- static/
|  +- templates/
|  +- main.py
|  +- requirements.txt
|
+- dockerfile
      </code>
    </pre>
  </p>

  <h2 id="dockerize">Dockerize</h2>
  <p>
    Now that we have our app setup, it is time to <i>dockerize</i>.
    In the project root, our dockerfile is defined as:
    <pre>
      <code class="dockerfile">
FROM tiangolo/uwsgi-nginx-flask:python3.8

COPY ./app /app
WORKDIR /app

RUN pip3 install -r requirements.txt

ENV LISTEN_PORT 5001
EXPOSE 5001
      </code>
    </pre>
  </p>

  <p>
    Here we will be utilizing the
    <a
      href="https://github.com/tiangolo/uwsgi-nginx-flask-docker"
      target="_blank"
      rel="noopener noreferrer"
      >
      uwsgi-nginx-flask-docker
    </a>
      base image. This image contains everything we need
      to run our application, using uwsgi. The rest of the dockerfile
      copies our application code to the container, makes sure
      to install our dependencies, and sets up what ports our server
      will be listening on.
  </p>

  <p>
    What this gives us is a portable container
    to run our server on any machine that has docker installed, where
    the server will listen and server over localhost:5001. We can build
    this container using:
    <pre>
      <code class="Bash">
docker build -t site
      </code>
    </pre>
  </p>

  <p>
    Once this is built, we can then run our container with:
    <pre>
      <code class="Bash">
docker run docker run -d --restart always -p 5001:5001 site
      </code>
    </pre>
    Now, go to localhost:5001 and check to see if our server is
    working. If using the example project, you should see:
    <img
      src="/static/blog/img/flask-docker-example.png"
      />
  </p>
  <p>
    Now that we know our container is working, we can push it
    to docker hub and run it from elsewhere.

    PUSH TO DOCKER HUB
  </p>


  <h2 id="deploy">Deploying Our App</h2>
  <p>
    Now that we have a working app, its time to deploy it!
    There are two things that you'll need in order to do this:
    a domain name and a server. For the domain name, I like
    <a
      href="https://www.namecheap.com/"
      target="_blank"
      rel="noreferrer noopener"
      >
      NameCheap,
    </a>
    as they have an easy to use platform and have good prices.
    For the server, any VPS solution would work, but I like
    <a
      href="https://www.vultr.com/?ref=8614760-6G"
      target="_blank"
      rel="noopener noreferrer"
      >
      Vultr.
    </a>
    If you sign up with that link, you'll get a $100 credit
    to try the platform. Regardless of what services you use,
    the process is nearly the same.
  </p>
  <p>

  </p>

  get domain
  point domain to VPS's name servers
  create instance on VPS (cloud compute)
  point domain name to IP address of instance on VPS
  ssh into VPS
  install docker, nginx, cerbot, python3-certbot
  initial nginx config
  run docker image
  test http
  run certbot --nginx
  test https
  create cronjob to auto renew
  conclusion


</div>
